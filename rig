#!/usr/bin/env bash
set -euo pipefail

# =============================================================================
# Rig CLI
# https://github.com/X-Zero-L/rig
#
# Usage:
#   rig install                    # Interactive install
#   rig install --all              # Install everything
#   rig update                     # Interactive update
#   rig update --all               # Update all installed
#   rig status                     # Show installed components
#   rig export                     # Export configuration
#   rig import <file>              # Import configuration
#   rig uninstall                  # Uninstall components
#   rig version                    # Show version
#   rig help                       # Show this help
#
# Environment variables:
#   GH_PROXY          - GitHub proxy URL (e.g. https://gh-proxy.org)
# =============================================================================

VERSION="0.1.0"

# Prevent gh-proxy.org from rewriting these URLs in proxied content
_GH="github.com"
_RAW="raw.githubusercontent.com"
REPO="X-Zero-L/rig"
BRANCH="master"
BASE_URL="https://${_RAW}/${REPO}/${BRANCH}"

export GH_PROXY="${GH_PROXY:-}"

# --- Security: GH_PROXY validation ------------------------------------------
# SECURITY WARNING — Supply-chain risk:
# This script downloads and executes remote shell scripts via `curl | bash`.
# The scripts are fetched from a GitHub branch (a moving target) and are NOT
# integrity-verified (no checksum or signature). If GH_PROXY is set, traffic
# is routed through a third-party proxy, adding MITM risk. Only use trusted
# HTTPS proxies. HTTP proxies are rejected to reduce interception surface.
# TODO: A future --verify flag may add SHA256 checksum verification.

validate_gh_proxy() {
    if [[ -n "$GH_PROXY" ]]; then
        if [[ "$GH_PROXY" != https://* ]]; then
            die "GH_PROXY must use https:// (got: $GH_PROXY). HTTP proxies are rejected to prevent MITM attacks."
        fi
    fi
}

# --- Colors ------------------------------------------------------------------

setup_colors() {
    if [[ -t 1 ]] || [[ "${FORCE_COLOR:-}" == "1" ]]; then
        RED='\033[0;31m'
        GREEN='\033[0;32m'
        YELLOW='\033[0;33m'
        CYAN='\033[0;36m'
        WHITE='\033[1;37m'
        BOLD='\033[1m'
        DIM='\033[2m'
        NC='\033[0m'
    else
        RED='' GREEN='' YELLOW='' CYAN='' WHITE=''
        BOLD='' DIM='' NC=''
    fi
}

# --- Helpers -----------------------------------------------------------------

die() {
    printf "${RED}error:${NC} %s\n" "$1" >&2
    exit 1
}

build_url() {
    local script="$1"
    if [[ -n "$GH_PROXY" ]]; then
        printf '%s' "${GH_PROXY%/}/${BASE_URL}/${script}"
    else
        printf '%s' "${BASE_URL}/${script}"
    fi
}

download_and_run() {
    local script="$1"
    shift

    if ! command -v curl &>/dev/null; then
        die "curl is required but not found"
    fi

    # Download script and lib dependencies to a temp directory so that
    # BASH_SOURCE resolves correctly and lib/ sourcing works.
    local tmpdir
    tmpdir=$(mktemp -d)

    # Download lib files first (scripts source these); fail early on error
    mkdir -p "$tmpdir/lib"
    local lib_file
    for lib_file in os-detect.sh pkg-maps.sh pkg-manager.sh; do
        if ! curl -fsSL "$(build_url "lib/$lib_file")" -o "$tmpdir/lib/$lib_file" 2>/dev/null; then
            rm -rf "$tmpdir"
            die "Failed to download lib/$lib_file"
        fi
    done

    # Download the target script
    if ! curl -fsSL "$(build_url "$script")" -o "$tmpdir/$script"; then
        rm -rf "$tmpdir"
        die "Failed to download $script"
    fi
    chmod +x "$tmpdir/$script"

    # Run script in a subshell so cleanup happens after it exits.
    # Cannot use exec here because that would skip cleanup.
    bash "$tmpdir/$script" "$@"
    local rc=$?
    rm -rf "$tmpdir"
    exit $rc
}

# --- Self-update -------------------------------------------------------------

self_update() {
    setup_colors
    local install_path
    install_path="$(command -v rig 2>/dev/null || echo "$HOME/.local/bin/rig")"

    if [[ ! -w "$install_path" ]]; then
        die "Cannot write to $install_path. Check permissions."
    fi

    printf "  ${DIM}Updating rig CLI from ${_GH}/${REPO}...${NC}\n"

    local tmpfile
    tmpfile=$(mktemp)
    if ! curl -fsSL "$(build_url "rig")" -o "$tmpfile"; then
        rm -f "$tmpfile"
        die "Failed to download latest rig CLI"
    fi

    # Check we got a valid script
    if ! head -1 "$tmpfile" | grep -q "^#!/"; then
        rm -f "$tmpfile"
        die "Downloaded file does not look like a valid script"
    fi

    # Extract remote version
    local remote_version
    remote_version=$(grep '^VERSION=' "$tmpfile" | head -1 | cut -d'"' -f2)

    mv -f "$tmpfile" "$install_path"
    chmod +x "$install_path"

    printf "  ${GREEN}Updated!${NC} %s → %s\n" "$VERSION" "${remote_version:-unknown}"
    printf "  ${DIM}Location: %s${NC}\n" "$install_path"
}

# --- Help --------------------------------------------------------------------

show_help() {
    setup_colors
    printf "\n"
    printf "  ${CYAN}${BOLD}Rig${NC} ${DIM}— development environment manager${NC}\n"
    printf "  ${DIM}${_GH}/${REPO}${NC}\n"
    printf "\n"
    printf "  ${BOLD}Usage:${NC}\n"
    printf "    rig <command> [options]\n"
    printf "\n"
    printf "  ${BOLD}Commands:${NC}\n"
    printf "    ${WHITE}install${NC}     Install components (interactive TUI)\n"
    printf "    ${WHITE}update${NC}      Update installed components\n"
    printf "    ${WHITE}status${NC}      Show installed component status\n"
    printf "    ${WHITE}export${NC}      Export current configuration\n"
    printf "    ${WHITE}import${NC}      Import configuration from file\n"
    printf "    ${WHITE}uninstall${NC}   Uninstall components\n"
    printf "    ${WHITE}self-update${NC}  Update the rig CLI itself\n"
    printf "    ${WHITE}version${NC}     Show rig version\n"
    printf "    ${WHITE}help${NC}        Show this help\n"
    printf "\n"
    printf "  ${BOLD}Options:${NC}\n"
    printf "    --gh-proxy URL   GitHub proxy (or set ${CYAN}GH_PROXY${NC} env var)\n"
    printf "                     ${DIM}Must use https://. HTTP proxies are rejected.${NC}\n"
    printf "\n"
    printf "  ${BOLD}Security:${NC}\n"
    printf "    ${DIM}Commands download and execute scripts from GitHub via curl | bash.${NC}\n"
    printf "    ${DIM}Scripts are fetched from a branch (not pinned) and are not integrity-${NC}\n"
    printf "    ${DIM}verified. When using --gh-proxy, only trusted HTTPS proxies should be${NC}\n"
    printf "    ${DIM}used. Review the source at: ${_GH}/${REPO}${NC}\n"
    printf "\n"
    printf "  ${BOLD}Examples:${NC}\n"
    printf "    rig install                          ${DIM}# Interactive TUI${NC}\n"
    printf "    rig install --all                    ${DIM}# Install everything${NC}\n"
    printf "    rig install --components shell,node   ${DIM}# Specific components${NC}\n"
    printf "    rig update --all                     ${DIM}# Update all installed${NC}\n"
    printf "    rig status                           ${DIM}# Check what's installed${NC}\n"
    printf "    rig export > my-config.json          ${DIM}# Save configuration${NC}\n"
    printf "    rig import my-config.json            ${DIM}# Restore configuration${NC}\n"
    printf "\n"
}

# --- Main --------------------------------------------------------------------

main() {
    setup_colors

    # Parse global options before command
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --gh-proxy)
                if [[ $# -lt 2 ]]; then
                    echo "error: --gh-proxy requires an argument" >&2
                    exit 1
                fi
                GH_PROXY="$2"
                shift 2
                ;;
            -*)
                # Not a global option — break and let command handle it
                break
                ;;
            *)
                break
                ;;
        esac
    done

    # Validate GH_PROXY after all option parsing
    validate_gh_proxy

    local cmd="${1:-help}"
    shift || true

    case "$cmd" in
        install)
            download_and_run "install.sh" "$@"
            ;;
        update)
            download_and_run "update.sh" "$@"
            ;;
        status)
            download_and_run "status.sh" "$@"
            ;;
        export)
            download_and_run "export-config.sh" "$@"
            ;;
        import)
            download_and_run "import-config.sh" "$@"
            ;;
        uninstall)
            download_and_run "uninstall.sh" "$@"
            ;;
        self-update)
            self_update
            ;;
        version|-V|--version)
            printf "rig %s\n" "$VERSION"
            ;;
        help|-h|--help)
            show_help
            ;;
        *)
            printf "${RED}Unknown command:${NC} %s\n" "$cmd" >&2
            printf "Run ${BOLD}rig help${NC} for usage.\n" >&2
            exit 1
            ;;
    esac
}

main "$@"
