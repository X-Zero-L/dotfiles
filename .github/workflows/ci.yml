name: CI

on:
  push:
    branches: [master]
  pull_request:
    branches: [master]

jobs:
  # ── Job 1: Lint & Consistency ──────────────────────────────────────────
  lint:
    name: Lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Shellcheck — top-level scripts
        run: shellcheck --severity=error setup-*.sh install.sh update.sh status.sh export-config.sh import-config.sh uninstall.sh rig

      - name: Shellcheck — lib/ scripts
        run: shellcheck --severity=error lib/*.sh

      - name: Syntax check
        run: |
          status=0
          for f in setup-*.sh install.sh update.sh status.sh export-config.sh import-config.sh uninstall.sh rig lib/*.sh; do
            if bash -n "$f"; then
              echo "✔ $f"
            else
              echo "✘ $f"
              status=1
            fi
          done
          exit $status

      - name: Array consistency — install.sh
        run: |
          bash -c '
            eval "$(sed -n "/^# --- \[C\] Component Registry/,/^# --- \[D\]/p" install.sh | head -n -1)"
            names=(COMP_IDS COMP_NAMES COMP_DESCS COMP_SCRIPTS COMP_DEPS COMP_NEEDS_KEYS COMP_NEEDS_SUDO COMP_SELECTED COMP_INSTALL_ONLY)
            lengths=(
              ${#COMP_IDS[@]} ${#COMP_NAMES[@]} ${#COMP_DESCS[@]}
              ${#COMP_SCRIPTS[@]} ${#COMP_DEPS[@]} ${#COMP_NEEDS_KEYS[@]}
              ${#COMP_NEEDS_SUDO[@]} ${#COMP_SELECTED[@]} ${#COMP_INSTALL_ONLY[@]}
            )
            expected=${lengths[0]}
            ok=1
            for i in "${!lengths[@]}"; do
              if [[ "${lengths[$i]}" -ne "$expected" ]]; then
                echo "FAIL: ${names[$i]} has ${lengths[$i]} elements (expected $expected)"
                ok=0
              fi
            done
            if [[ $ok -eq 1 ]]; then
              echo "OK: install.sh — all 9 arrays have $expected elements"
            else
              exit 1
            fi
          '

      - name: Array consistency — update.sh
        run: |
          bash -c '
            eval "$(sed -n "/^# --- \[C\] Component Registry/,/^# --- \[D\]/p" update.sh | head -n -1)"
            names=(COMP_IDS COMP_NAMES COMP_DESCS COMP_NEEDS_SUDO COMP_INSTALLED COMP_SELECTED)
            lengths=(
              ${#COMP_IDS[@]} ${#COMP_NAMES[@]} ${#COMP_DESCS[@]}
              ${#COMP_NEEDS_SUDO[@]} ${#COMP_INSTALLED[@]} ${#COMP_SELECTED[@]}
            )
            expected=${lengths[0]}
            ok=1
            for i in "${!lengths[@]}"; do
              if [[ "${lengths[$i]}" -ne "$expected" ]]; then
                echo "FAIL: ${names[$i]} has ${lengths[$i]} elements (expected $expected)"
                ok=0
              fi
            done
            if [[ $ok -eq 1 ]]; then
              echo "OK: update.sh — all 6 arrays have $expected elements"
            else
              exit 1
            fi
          '

      - name: COMP_IDS sync between install.sh and update.sh
        run: |
          install_ids=$(bash -c 'eval "$(sed -n "/^COMP_IDS=/p" install.sh)"; echo "${COMP_IDS[*]}"')
          update_ids=$(bash -c 'eval "$(sed -n "/^COMP_IDS=/p" update.sh)"; echo "${COMP_IDS[*]}"')
          if [[ "$install_ids" != "$update_ids" ]]; then
            echo "FAIL: COMP_IDS mismatch"
            echo "  install.sh: $install_ids"
            echo "  update.sh:  $update_ids"
            exit 1
          fi
          echo "OK: COMP_IDS match — $install_ids"

      - name: COMP_SCRIPTS match setup files
        run: |
          bash -c '
            eval "$(sed -n "/^COMP_SCRIPTS=/,/)/p" install.sh)"
            status=0
            for script in "${COMP_SCRIPTS[@]}"; do
              if [[ ! -f "$script" ]]; then
                echo "FAIL: $script referenced in COMP_SCRIPTS but file not found"
                status=1
              fi
            done
            if [[ $status -eq 0 ]]; then
              echo "OK: all ${#COMP_SCRIPTS[@]} scripts exist"
            fi
            exit $status
          '

  # ── Job 2: OS Detection Tests ─────────────────────────────────────────
  # Validates lib/os-detect.sh returns correct values on each target OS.
  # This runs first (after lint) to catch OS detection regressions early.
  os-detect-test:
    name: OS Detect (${{ matrix.os }})
    needs: lint
    runs-on: ${{ matrix.runner }}
    timeout-minutes: 5
    strategy:
      fail-fast: false
      matrix:
        include:
          # Native Ubuntu runner
          - os: ubuntu
            runner: ubuntu-latest
            expect_family: debian
            expect_distro: Ubuntu
            expect_pkg: apt

          # Native macOS runner
          - os: macos
            runner: macos-latest
            expect_family: macos
            expect_distro: macOS
            expect_pkg: brew

    steps:
      - uses: actions/checkout@v4

      - name: "Test: os-detect.sh sets correct variables"
        shell: bash
        run: |
          # Source the library and verify exported variables
          source lib/os-detect.sh

          echo "OS_FAMILY:   $OS_FAMILY"
          echo "OS_DISTRO:   $OS_DISTRO"
          echo "OS_VERSION:  $OS_VERSION"
          echo "PKG_MANAGER: $PKG_MANAGER"

          failed=0

          # Verify OS_FAMILY
          if [[ "$OS_FAMILY" != "${{ matrix.expect_family }}" ]]; then
            echo "FAIL: OS_FAMILY='$OS_FAMILY', expected '${{ matrix.expect_family }}'"
            failed=1
          else
            echo "✔ OS_FAMILY=$OS_FAMILY"
          fi

          # Verify OS_DISTRO
          if [[ "$OS_DISTRO" != "${{ matrix.expect_distro }}" ]]; then
            echo "FAIL: OS_DISTRO='$OS_DISTRO', expected '${{ matrix.expect_distro }}'"
            failed=1
          else
            echo "✔ OS_DISTRO=$OS_DISTRO"
          fi

          # Verify PKG_MANAGER
          if [[ "$PKG_MANAGER" != "${{ matrix.expect_pkg }}" ]]; then
            echo "FAIL: PKG_MANAGER='$PKG_MANAGER', expected '${{ matrix.expect_pkg }}'"
            failed=1
          else
            echo "✔ PKG_MANAGER=$PKG_MANAGER"
          fi

          # Verify OS_VERSION is not empty or unknown
          if [[ "$OS_VERSION" == "unknown" || -z "$OS_VERSION" ]]; then
            echo "FAIL: OS_VERSION is '$OS_VERSION'"
            failed=1
          else
            echo "✔ OS_VERSION=$OS_VERSION"
          fi

          exit $failed

      - name: "Test: convenience functions"
        shell: bash
        run: |
          source lib/os-detect.sh
          failed=0

          case "${{ matrix.expect_family }}" in
            debian)
              is_debian || { echo "FAIL: is_debian should return 0"; failed=1; }
              ! is_macos || { echo "FAIL: is_macos should return 1"; failed=1; }
              ! is_arch  || { echo "FAIL: is_arch should return 1"; failed=1; }
              ;;
            macos)
              is_macos  || { echo "FAIL: is_macos should return 0"; failed=1; }
              ! is_debian || { echo "FAIL: is_debian should return 1"; failed=1; }
              ! is_arch  || { echo "FAIL: is_arch should return 1"; failed=1; }
              ;;
          esac

          echo "✔ Convenience functions correct for ${{ matrix.expect_family }}"
          exit $failed

      - name: "Test: double-source guard"
        shell: bash
        run: |
          # Sourcing twice should not fail (guard prevents re-execution)
          source lib/os-detect.sh
          source lib/os-detect.sh
          echo "✔ Double-source guard works"

  # ── Job 2b: OS Detection — Container Tests ────────────────────────────
  # Validates lib/os-detect.sh inside Fedora and Arch Linux containers.
  os-detect-container-test:
    name: OS Detect (${{ matrix.os }})
    needs: lint
    runs-on: ubuntu-latest
    timeout-minutes: 10
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: fedora
            image: fedora:latest
            expect_family: fedora
            expect_distro: Fedora
            expect_pkg: dnf

          - os: arch
            image: archlinux:latest
            expect_family: arch
            expect_distro: Arch Linux
            expect_pkg: pacman

    container:
      image: ${{ matrix.image }}

    steps:
      - uses: actions/checkout@v4

      - name: "Test: os-detect.sh sets correct variables"
        shell: bash
        run: |
          source lib/os-detect.sh

          echo "OS_FAMILY:   $OS_FAMILY"
          echo "OS_DISTRO:   $OS_DISTRO"
          echo "OS_VERSION:  $OS_VERSION"
          echo "PKG_MANAGER: $PKG_MANAGER"

          failed=0

          if [[ "$OS_FAMILY" != "${{ matrix.expect_family }}" ]]; then
            echo "FAIL: OS_FAMILY='$OS_FAMILY', expected '${{ matrix.expect_family }}'"
            failed=1
          else
            echo "✔ OS_FAMILY=$OS_FAMILY"
          fi

          if [[ "$OS_DISTRO" != "${{ matrix.expect_distro }}" ]]; then
            echo "FAIL: OS_DISTRO='$OS_DISTRO', expected '${{ matrix.expect_distro }}'"
            failed=1
          else
            echo "✔ OS_DISTRO=$OS_DISTRO"
          fi

          if [[ "$PKG_MANAGER" != "${{ matrix.expect_pkg }}" ]]; then
            echo "FAIL: PKG_MANAGER='$PKG_MANAGER', expected '${{ matrix.expect_pkg }}'"
            failed=1
          else
            echo "✔ PKG_MANAGER=$PKG_MANAGER"
          fi

          exit $failed

  # ── Job 3: Smoke Tests ────────────────────────────────────────────────
  # Per-component install tests on Ubuntu (the primary target).
  smoke-test:
    name: ${{ matrix.component }}
    needs: lint
    runs-on: ubuntu-latest
    timeout-minutes: 15
    strategy:
      fail-fast: false
      matrix:
        include:
          - component: shell
            script: setup-shell.sh
            deps: ""
            verify: "zsh starship"

          - component: tmux
            script: setup-tmux.sh
            deps: ""
            verify: "tmux"

          - component: git
            script: setup-git.sh
            deps: ""
            verify: "git"

          - component: tools
            script: setup-tools.sh
            deps: ""
            verify: "rg jq tree shellcheck gcc wget unzip xclip"

          - component: clash
            script: setup-clash.sh
            deps: ""
            verify: ""

          - component: node
            script: setup-node.sh
            deps: ""
            verify: "node npm"

          - component: uv
            script: setup-uv.sh
            deps: ""
            verify: "uv"

          - component: go
            script: setup-go.sh
            deps: ""
            verify: "go"

          - component: docker
            script: setup-docker.sh
            deps: ""
            verify: "docker"

          - component: tailscale
            script: setup-tailscale.sh
            deps: ""
            verify: "tailscale"

          - component: ssh
            script: setup-ssh.sh
            deps: ""
            verify: "sshd"

          - component: claude-code
            script: setup-claude-code.sh
            deps: setup-node.sh
            verify: "claude"

          - component: codex
            script: setup-codex.sh
            deps: setup-node.sh
            verify: "codex"

          - component: gemini
            script: setup-gemini.sh
            deps: setup-node.sh
            verify: "gemini"

          - component: skills
            script: setup-skills.sh
            deps: setup-node.sh
            verify: ""

    steps:
      - uses: actions/checkout@v4

      - name: Install dependency
        if: matrix.deps != ''
        shell: bash
        run: bash ${{ matrix.deps }}

      - name: Run ${{ matrix.script }}
        shell: bash
        run: |
          # Load env from any prior dependency step
          export NVM_DIR="$HOME/.nvm"
          [ -s "$NVM_DIR/nvm.sh" ] && . "$NVM_DIR/nvm.sh"
          export PATH="$HOME/.local/bin:$PATH"
          [ -d "$HOME/.goenv" ] && {
            export GOENV_ROOT="$HOME/.goenv"
            export PATH="$GOENV_ROOT/bin:$PATH"
            eval "$(goenv init -)" 2>/dev/null || true
          }
          bash ${{ matrix.script }}

      - name: Verify commands
        if: matrix.verify != ''
        shell: bash
        run: |
          # Reload env
          export NVM_DIR="$HOME/.nvm"
          [ -s "$NVM_DIR/nvm.sh" ] && . "$NVM_DIR/nvm.sh"
          export PATH="$HOME/.local/bin:$PATH"
          [ -d "$HOME/.goenv" ] && {
            export GOENV_ROOT="$HOME/.goenv"
            export PATH="$GOENV_ROOT/bin:$PATH"
            eval "$(goenv init -)" 2>/dev/null || true
          }

          failed=0
          for cmd in ${{ matrix.verify }}; do
            if command -v "$cmd" &>/dev/null; then
              echo "✔ $cmd → $(command -v "$cmd")"
            else
              echo "✘ $cmd not found"
              failed=1
            fi
          done
          exit $failed

      - name: Idempotency re-run
        if: matrix.component == 'tools'
        shell: bash
        run: |
          export PATH="$HOME/.local/bin:$PATH"
          bash ${{ matrix.script }}
          echo "✔ Idempotent re-run succeeded"

  # ── Job 3b: Smoke Tests — macOS ──────────────────────────────────────
  # Basic install validation on macOS to verify cross-platform support.
  smoke-test-macos:
    name: smoke-macos (${{ matrix.component }})
    needs: lint
    runs-on: macos-latest
    timeout-minutes: 15
    strategy:
      fail-fast: false
      matrix:
        include:
          # Test the tools component on macOS (exercises pkg_install + macOS code paths)
          - component: tools
            script: setup-tools.sh
            deps: ""
            verify: "rg jq tree shellcheck wget"

          # Test node install on macOS
          - component: node
            script: setup-node.sh
            deps: ""
            verify: "node npm"

          # Test uv install on macOS
          - component: uv
            script: setup-uv.sh
            deps: ""
            verify: "uv"

          # Test go install on macOS
          - component: go
            script: setup-go.sh
            deps: ""
            verify: "go"

    steps:
      - uses: actions/checkout@v4

      - name: Install dependency
        if: matrix.deps != ''
        shell: bash
        run: bash ${{ matrix.deps }}

      - name: Run ${{ matrix.script }}
        shell: bash
        run: |
          export NVM_DIR="$HOME/.nvm"
          [ -s "$NVM_DIR/nvm.sh" ] && . "$NVM_DIR/nvm.sh"
          export PATH="$HOME/.local/bin:$PATH"
          [ -d "$HOME/.goenv" ] && {
            export GOENV_ROOT="$HOME/.goenv"
            export PATH="$GOENV_ROOT/bin:$PATH"
            eval "$(goenv init -)" 2>/dev/null || true
          }
          bash ${{ matrix.script }}

      - name: Verify commands
        if: matrix.verify != ''
        shell: bash
        run: |
          export NVM_DIR="$HOME/.nvm"
          [ -s "$NVM_DIR/nvm.sh" ] && . "$NVM_DIR/nvm.sh"
          export PATH="$HOME/.local/bin:$PATH"
          [ -d "$HOME/.goenv" ] && {
            export GOENV_ROOT="$HOME/.goenv"
            export PATH="$GOENV_ROOT/bin:$PATH"
            eval "$(goenv init -)" 2>/dev/null || true
          }

          failed=0
          for cmd in ${{ matrix.verify }}; do
            if command -v "$cmd" &>/dev/null; then
              echo "✔ $cmd → $(command -v "$cmd")"
            else
              echo "✘ $cmd not found"
              failed=1
            fi
          done
          exit $failed

  # ── Job 3c: Smoke Tests — Linux Containers ───────────────────────────
  # Validates basic install on Fedora and Arch Linux via containers.
  smoke-test-container:
    name: smoke-container (${{ matrix.os }})
    needs: lint
    runs-on: ubuntu-latest
    timeout-minutes: 15
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: fedora
            image: fedora:latest
          - os: arch
            image: archlinux:latest

    container:
      image: ${{ matrix.image }}

    steps:
      - uses: actions/checkout@v4

      # Install minimal dependencies that containers lack
      - name: Install prerequisites
        shell: bash
        run: |
          if command -v dnf &>/dev/null; then
            dnf install -y curl bash git sudo findutils
          elif command -v pacman &>/dev/null; then
            pacman -Sy --noconfirm curl bash git sudo
          fi

      - name: "Test: os-detect.sh loads correctly"
        shell: bash
        run: |
          source lib/os-detect.sh
          echo "OS_FAMILY=$OS_FAMILY OS_DISTRO=$OS_DISTRO PKG_MANAGER=$PKG_MANAGER"
          [[ "$OS_FAMILY" != "unknown" ]] || { echo "FAIL: OS_FAMILY is unknown"; exit 1; }
          echo "✔ OS detection works on ${{ matrix.os }}"

      - name: "Test: setup-tools.sh basic install"
        shell: bash
        run: |
          # Run tools setup — exercises pkg_install on this OS
          bash setup-tools.sh

      - name: Verify core tools installed
        shell: bash
        run: |
          export PATH="$HOME/.local/bin:$PATH"
          failed=0
          # Check a subset of tools that should work on all Linux distros
          for cmd in rg jq tree wget; do
            if command -v "$cmd" &>/dev/null; then
              echo "✔ $cmd → $(command -v "$cmd")"
            else
              echo "✘ $cmd not found"
              failed=1
            fi
          done
          exit $failed

  # ── Job 4: install.sh E2E ─────────────────────────────────────────────
  install-e2e:
    name: install.sh E2E (${{ matrix.os }})
    needs: lint
    runs-on: ${{ matrix.runner }}
    timeout-minutes: 20
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu
            runner: ubuntu-latest
          - os: macos
            runner: macos-latest

    steps:
      - uses: actions/checkout@v4

      - name: Start local file server
        run: |
          python3 -m http.server 8888 &
          sleep 1
          curl -sf http://localhost:8888/setup-tools.sh > /dev/null
          echo "✔ Local server serving repo files"

      - name: Patch install.sh to use local server
        run: |
          sed 's|^BASE_URL=.*|BASE_URL="http://localhost:8888"|' install.sh > /tmp/install-local.sh
          chmod +x /tmp/install-local.sh

      - name: "Test: --components tools"
        run: bash /tmp/install-local.sh --components tools --verbose

      - name: Verify tools installed
        run: |
          export PATH="$HOME/.local/bin:$PATH"
          failed=0
          # Core tools expected on both Ubuntu and macOS
          for cmd in rg jq tree shellcheck wget; do
            if command -v "$cmd" > /dev/null; then
              echo "✔ $cmd"
            else
              echo "✘ $cmd"
              failed=1
            fi
          done
          # Ubuntu-only tools (xclip, gcc/unzip already present on macOS)
          if [[ "$(uname -s)" == "Linux" ]]; then
            for cmd in gcc unzip xclip; do
              command -v "$cmd" > /dev/null || { echo "✘ $cmd"; failed=1; }
              echo "✔ $cmd"
            done
          fi
          exit $failed

      - name: "Test: dependency resolution (claude-code -> node)"
        run: bash /tmp/install-local.sh --components claude-code --verbose

      - name: Verify dependency auto-added node
        shell: bash
        run: |
          export NVM_DIR="$HOME/.nvm"
          [ -s "$NVM_DIR/nvm.sh" ] && . "$NVM_DIR/nvm.sh"
          command -v node || { echo "✘ node not auto-installed"; exit 1; }
          command -v claude || { echo "✘ claude not installed"; exit 1; }
          echo "✔ Dependency resolution: claude-code pulled in node"

      - name: "Test: --components with multiple items"
        run: bash /tmp/install-local.sh --components uv,go --verbose

      - name: Verify multi-component install
        shell: bash
        run: |
          export PATH="$HOME/.local/bin:$PATH"
          [ -d "$HOME/.goenv" ] && {
            export GOENV_ROOT="$HOME/.goenv"
            export PATH="$GOENV_ROOT/bin:$PATH"
            eval "$(goenv init -)" 2>/dev/null || true
          }
          command -v uv || { echo "✘ uv"; exit 1; }
          command -v go || { echo "✘ go"; exit 1; }
          echo "✔ Multi-component install: uv + go"

  # ── Job 5: update.sh E2E ──────────────────────────────────────────────
  update-e2e:
    name: update.sh E2E (${{ matrix.os }})
    needs: lint
    runs-on: ${{ matrix.runner }}
    timeout-minutes: 20
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu
            runner: ubuntu-latest
          - os: macos
            runner: macos-latest

    steps:
      - uses: actions/checkout@v4

      - name: Pre-install components (tools + node)
        run: |
          bash setup-tools.sh
          bash setup-node.sh

      - name: "Test: update.sh --components tools,node --verbose"
        shell: bash
        run: |
          export NVM_DIR="$HOME/.nvm"
          [ -s "$NVM_DIR/nvm.sh" ] && . "$NVM_DIR/nvm.sh"
          export PATH="$HOME/.local/bin:$PATH"
          bash update.sh --components tools,node --verbose

      - name: "Test: update.sh --all detects installed components"
        shell: bash
        run: |
          export NVM_DIR="$HOME/.nvm"
          [ -s "$NVM_DIR/nvm.sh" ] && . "$NVM_DIR/nvm.sh"
          export PATH="$HOME/.local/bin:$PATH"
          output=$(bash update.sh --all --verbose 2>&1) || true
          echo "$output"
          echo "$output" | grep -q "Essential Tools" || { echo "FAIL: tools not detected"; exit 1; }
          echo "$output" | grep -q "Node.js" || { echo "FAIL: node not detected"; exit 1; }
          echo "✔ update --all: detection + update completed"

      - name: "Test: update.sh skips non-installed components"
        shell: bash
        run: |
          export NVM_DIR="$HOME/.nvm"
          [ -s "$NVM_DIR/nvm.sh" ] && . "$NVM_DIR/nvm.sh"
          export PATH="$HOME/.local/bin:$PATH"
          output=$(bash update.sh --components gemini 2>&1) || true
          echo "$output"
          echo "$output" | grep -q "not installed, skipping" || { echo "FAIL: should warn about non-installed"; exit 1; }
          echo "✔ Non-installed component correctly skipped"

  # ── Job 6: Management Scripts E2E ──────────────────────────────────────
  # Management scripts are tested on Ubuntu only for now.
  management-e2e:
    name: Management E2E
    needs: lint
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - uses: actions/checkout@v4

      - name: "Syntax check: management scripts"
        run: |
          for f in rig status.sh export-config.sh import-config.sh uninstall.sh; do
            bash -n "$f" || { echo "✘ $f"; exit 1; }
            echo "✔ $f"
          done

      - name: "Test: rig CLI — version"
        run: |
          output=$(bash rig version)
          echo "$output"
          echo "$output" | grep -qE '^rig [0-9]+\.' || { echo "FAIL: unexpected version format"; exit 1; }
          echo "✔ rig version"

      - name: "Test: rig CLI — help"
        run: |
          output=$(bash rig help)
          echo "$output"
          echo "$output" | grep -q "install" || { echo "FAIL: help missing install"; exit 1; }
          echo "$output" | grep -q "update" || { echo "FAIL: help missing update"; exit 1; }
          echo "$output" | grep -q "status" || { echo "FAIL: help missing status"; exit 1; }
          echo "✔ rig help"

      - name: "Test: rig CLI — unknown command"
        run: |
          if bash rig badcommand 2>/dev/null; then
            echo "FAIL: should have exited non-zero"
            exit 1
          fi
          echo "✔ rig unknown command exits non-zero"

      - name: Pre-install components for testing
        run: |
          bash setup-tools.sh
          export PATH="$HOME/.local/bin:$PATH"
          echo "✔ Pre-installed tools for management tests"

      - name: "Test: install.sh --preset minimal"
        run: |
          python3 -m http.server 8888 &
          sleep 1
          sed 's|^BASE_URL=.*|BASE_URL="http://localhost:8888"|' install.sh > /tmp/install-local.sh
          chmod +x /tmp/install-local.sh
          bash /tmp/install-local.sh --preset minimal --verbose
          export PATH="$HOME/.local/bin:$PATH"
          for cmd in zsh rg jq git; do
            command -v "$cmd" || { echo "✘ $cmd not found after --preset minimal"; exit 1; }
            echo "✔ $cmd"
          done
          echo "✔ --preset minimal installed shell, tools, git"
          kill %1 2>/dev/null || true

      - name: "Test: status.sh — table output"
        run: |
          export PATH="$HOME/.local/bin:$PATH"
          output=$(bash status.sh)
          echo "$output"
          echo "$output" | grep -q "Shell" || { echo "FAIL: missing Shell in status"; exit 1; }
          echo "✔ status.sh table output"

      - name: "Test: status.sh — JSON output"
        run: |
          export PATH="$HOME/.local/bin:$PATH"
          output=$(bash status.sh --json)
          echo "$output"
          echo "$output" | jq -e '.components' > /dev/null || { echo "FAIL: invalid JSON from status.sh"; exit 1; }
          echo "✔ status.sh JSON output valid"

      - name: "Test: status.sh — short output"
        run: |
          export PATH="$HOME/.local/bin:$PATH"
          output=$(bash status.sh --short)
          echo "$output"
          echo "$output" | grep -q "rig:" || { echo "FAIL: unexpected short format"; exit 1; }
          echo "✔ status.sh short output"

      - name: "Test: export-config.sh — JSON mode"
        run: |
          export PATH="$HOME/.local/bin:$PATH"
          output=$(bash export-config.sh --json)
          echo "$output"
          echo "$output" | jq -e '.components' > /dev/null || { echo "FAIL: invalid JSON from export"; exit 1; }
          echo "$output" | jq -e '.config' > /dev/null || { echo "FAIL: missing config in export"; exit 1; }
          echo "✔ export-config.sh JSON output valid"

      - name: "Test: export-config.sh — file mode"
        run: |
          export PATH="$HOME/.local/bin:$PATH"
          bash export-config.sh --output-dir /tmp/rig-ci-export --no-secrets
          [ -f /tmp/rig-ci-export/rig-config.json ] || { echo "FAIL: config file not created"; exit 1; }
          jq -e '.components' /tmp/rig-ci-export/rig-config.json > /dev/null || { echo "FAIL: invalid config JSON"; exit 1; }
          echo "✔ export-config.sh file output"

      - name: "Test: import-config.sh — plan display"
        run: |
          export PATH="$HOME/.local/bin:$PATH"
          # Test validation: no args
          bash import-config.sh 2>&1 && { echo "FAIL: should fail with no args"; exit 1; } || true
          # Test validation: missing file
          bash import-config.sh /tmp/nonexistent.json 2>&1 && { echo "FAIL: should fail with missing file"; exit 1; } || true
          echo "✔ import-config.sh validation works"

      - name: "Test: uninstall.sh — help"
        run: |
          output=$(bash uninstall.sh --help 2>&1) || true
          echo "$output"
          echo "✔ uninstall.sh help"

      - name: "Test: uninstall.sh — dependency check"
        run: |
          export PATH="$HOME/.local/bin:$PATH"
          # uninstall.sh should handle non-installed components gracefully
          output=$(bash uninstall.sh --components clash --yes 2>&1) || true
          echo "$output"
          echo "✔ uninstall.sh handles non-installed components"
